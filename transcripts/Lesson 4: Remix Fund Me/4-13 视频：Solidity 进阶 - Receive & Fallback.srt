1
00:00:01,740 --> 00:00:05,160
现在让我们再看看改进这个合约的另一个方法

2
00:00:05,160 --> 00:00:09,491
有时可以直接将 ETH 或原生通证发送给智能合约

3
00:00:09,491 --> 00:00:13,865
而不执行某一个具体的函数来发送通证

4
00:00:13,865 --> 00:00:16,710
例如,在这里的 JavaScript EVM 上

5
00:00:16,710 --> 00:00:21,720
我可以在不调用 fund 函数的情况下，向合约发送资金

6
00:00:21,760 --> 00:00:24,510
然而,如果我这样做的话

7
00:00:24,510 --> 00:00:26,330
这时会对我们的 fund 函数产生什么作用吗？

8
00:00:26,330 --> 00:00:29,830
不,它不会被触发, 我们将无法跟踪那个 funder

9
00:00:29,990 --> 00:00:33,660
我们不会在这个合约中更新那个人的信息

10
00:00:33,660 --> 00:00:36,079
因此,如果以后我们想给予奖励或什么

11
00:00:36,079 --> 00:00:38,767
那就不妙了,因为人们在我们不知道的情况下给合约发送资金

12
00:00:38,767 --> 00:00:45,120
我们就不能给他们任何凭证或其他东西

13
00:00:45,140 --> 00:00:46,466
此外

14
00:00:46,466 --> 00:00:49,425
也许他们意外地调用了错误的函数

15
00:00:49,425 --> 00:00:52,926
他们又可能没有使用 MetaMask，或者其他工具来告诉他们

16
00:00:52,926 --> 00:00:54,740
嘿,这个交易很可能会失败

17
00:00:54,740 --> 00:00:56,760
那么,在这种情况下我们能做什么呢？

18
00:00:56,840 --> 00:01:01,277
如果有人在没有调用 fund 函数的情况下

19
00:01:01,277 --> 00:01:06,260
给这个合约发送 ETH 以太币, 会发生什么呢？

20
00:01:06,260 --> 00:01:09,658
现在,如果我们要给 FundMe 合约发送 ETH

21
00:01:09,658 --> 00:01:11,260
它会直接转到合约,对吧？

22
00:01:11,260 --> 00:01:13,475
这个合约不会记录这些人的情况

23
00:01:13,475 --> 00:01:17,291
但是实际上有一种方法,当人们给这个合约转钱

24
00:01:17,291 --> 00:01:19,595
或者人们调用一个不存在的函数

25
00:01:19,595 --> 00:01:21,620
我们仍然可以触发合约的某些代码

26
00:01:21,620 --> 00:01:24,740
而现在在 Solidity 中有两个特殊的函数

27
00:01:24,740 --> 00:01:27,408
一个叫做 receive

28
00:01:27,408 --> 00:01:30,160
一个叫做 fallback

29
00:01:30,580 --> 00:01:34,160
在 Solidity 中,实际上有很多特殊的函数

30
00:01:34,320 --> 00:01:40,070
其中有两个特殊的函数是 receive 特殊函数和 fallback 特殊函数

31
00:01:40,070 --> 00:01:42,496
一个合约最多可以有一个使用 receive 函数

32
00:01:42,496 --> 00:01:45,425
使用 receive() external payable {...}

33
00:01:45,425 --> 00:01:47,430
不需要使用 function 关键字

34
00:01:47,430 --> 00:01:49,796
这个函数不能有参数不能返回任何东西

35
00:01:49,796 --> 00:01:53,760
必须是 external 以及 payable 函数

36
00:01:53,760 --> 00:01:55,900
这是什么意思呢？或者说看起来像什么？

37
00:01:56,060 --> 00:01:59,880
好吧,让我们单独创建一个的合约来试一试

38
00:01:59,880 --> 00:02:01,742
所以,在这里,我们要创建一个新的文件

39
00:02:01,742 --> 00:02:05,290
叫做 FallbackExample.sol

40
00:02:05,450 --> 00:02:07,871
在这里,我们要添加我们的基本部分

41
00:02:07,871 --> 00:02:10,483
SPX 许可证标识符, 添加 // SPDX-License-Identifier: MIT 

42
00:02:10,483 --> 00:02:15,540
和 Solidity 版本 0.8.7

43
00:02:15,940 --> 00:02:19,660
写合约 FallbackExample

44
00:02:20,100 --> 00:02:21,766
就像这样 

45
00:02:21,766 --> 00:02:23,840
请随意暂停视频,动手敲代码赶上我

46
00:02:24,000 --> 00:02:26,117
一旦创建好了我们的 fallback 合约

47
00:02:26,117 --> 00:02:29,540
让我们创建一个变量来测试这个函数

48
00:02:29,870 --> 00:02:33,821
我们将创建一个 uint256 public result 变量

49
00:02:33,821 --> 00:02:36,060
让我们创建这个 receive 函数

50
00:02:36,220 --> 00:02:42,320
所以我们会说 receive,它将是一个external payable的函数

51
00:02:42,480 --> 00:02:46,119
我们不需要为 receive 添加 function 关键字

52
00:02:46,119 --> 00:02:50,060
因为 Solidity 知道,receive 就是一个特殊的函数

53
00:02:50,220 --> 00:02:54,850
只要我们发送 ETH 或向这个合约发送交易

54
00:02:54,870 --> 00:03:01,020
只要没有与该交易相关的数据, 这个 receive 函数就会被触发

55
00:03:01,180 --> 00:03:06,150
我们现在可以在这里做的是,我们可以说 result = 1;

56
00:03:06,410 --> 00:03:09,990
所以,让我们继续在 JavaScript 虚拟机上测试这个

57
00:03:10,210 --> 00:03:13,110
我们编译这个,所以我们要继续编译这个

58
00:03:13,280 --> 00:03:15,960
我们将在 Java 虚拟机上部署它,

59
00:03:16,180 --> 00:03:18,820
我们将部署我们的 FallbackExample

60
00:03:18,820 --> 00:03:21,920
我们将看到 result 被初始值是什么

61
00:03:22,240 --> 00:03:24,220
因为我们没有为 result 设置任何东西

62
00:03:24,220 --> 00:03:27,260
result 当然是被初始化为 0

63
00:03:27,260 --> 00:03:31,240
但如果我们向这个合约发送一些 ETH 呢？

64
00:03:31,420 --> 00:03:33,820
好吧,receive 将继续进行并在这里被触发

65
00:03:33,980 --> 00:03:36,740
我们实际上可以直接向这个合约发送一些数据

66
00:03:36,740 --> 00:03:38,820
通过与这里的 Low level interaction

67
00:03:38,820 --> 00:03:41,580
你暂时不需要关心 calldata 的含义

68
00:03:41,580 --> 00:03:46,600
只需要知道这个区域是一种发送和处理不同函数的方式

69
00:03:46,600 --> 00:03:52,460
而且我们可以在这个交易中添加参数,通过这里去调整上面的变量

70
00:03:52,790 --> 00:03:54,216
如果我们保持 calldata 留空

71
00:03:54,216 --> 00:04:00,370
就像是在 metamask 中，点击 send，然后直接选合约地址一样

72
00:04:00,370 --> 00:04:04,124
同样,我们不能使用 MetaMask,因为这是一个虚拟机环境

73
00:04:04,124 --> 00:04:06,480
而不是我们正在使用的网络之一

74
00:04:06,640 --> 00:04:08,143
因此,如果我这样做

75
00:04:08,143 --> 00:04:12,708
例如，我把这个值改为 1 Wei,并保持剩下的空值

76
00:04:12,708 --> 00:04:15,511
然后点击这个交易按钮

77
00:04:15,511 --> 00:04:20,800
同样,这将与点击这个发送按钮一样,但只发送 1 Wei

78
00:04:20,800 --> 00:04:21,960
你认为会发生什么？

79
00:04:21,960 --> 00:04:23,652
好吧,让我们来试试

80
00:04:23,652 --> 00:04:27,720
我们可以在日志区看到,我们确实发送了一个交易

81
00:04:27,850 --> 00:04:30,878
如果你看一下这里的描述

82
00:04:30,878 --> 00:04:33,917
你甚至可以看到它说发送自 0xxx 地址

83
00:04:33,917 --> 00:04:36,726
到了我们的 FallbackExample.(receive)

84
00:04:36,726 --> 00:04:39,375
看起来它调用了我们的 receive 函数

85
00:04:39,375 --> 00:04:42,160
这应该把我们的 result 更新为 1

86
00:04:42,160 --> 00:04:44,037
因此,如果我们现在点击 result

87
00:04:44,037 --> 00:04:48,610
我们确实可以看到 result 已经被更新为 1 的值

88
00:04:48,770 --> 00:04:50,230
好吧,让我们继续下去,删除这个

89
00:04:50,230 --> 00:04:55,550
让我们再次部署这个合约, 这一次,让我们把这个值设为 0

90
00:04:55,750 --> 00:04:57,450
这次会不会被触发

91
00:04:57,450 --> 00:05:00,790
所以让我们滑下来,点击交易

92
00:05:00,790 --> 00:05:02,290
让我们把 calldata 留空,

93
00:05:02,290 --> 00:05:04,218
我们把值留为 0

94
00:05:04,218 --> 00:05:10,413
这相当于我们向该合约发送 0 个 ETH

95
00:05:10,413 --> 00:05:12,329
点击交易

96
00:05:12,329 --> 00:05:13,850
看起来已经通过了

97
00:05:13,850 --> 00:05:17,050
你认为 result 会是 1 还是 0？

98
00:05:17,210 --> 00:05:18,790
你认为是 1？你是正确的

99
00:05:18,790 --> 00:05:22,313
当你向合约发送交易的时候,如果没有指定某个函数

100
00:05:22,313 --> 00:05:27,985
receive 函数就会被触发（当 calldata 没有值时）

101
00:05:27,985 --> 00:05:31,200
在任何其他合约如 FundMe 中

102
00:05:31,200 --> 00:05:33,404
例如,当我们调用这些函数之一时

103
00:05:33,404 --> 00:05:36,690
我们实际上只是用某些数据来填充这个 calldata

104
00:05:36,690 --> 00:05:39,250
这些数据指向这里的这些函数之一

105
00:05:39,410 --> 00:05:42,409
如果我们发送一个交易并向其添加数据

106
00:05:42,409 --> 00:05:44,490
我们实际上可以调用这些函数中的一个

107
00:05:44,650 --> 00:05:46,850
现在让我们再试一下,让我们再次删除合约,我们将重新部署

108
00:05:47,010 --> 00:05:50,610
打开这个,result 目前是 0

109
00:05:50,770 --> 00:05:55,590
receive,就像我说的,只有当 calldata 是空白时才会被触发

110
00:05:55,770 --> 00:05:58,075
现在,如果我对这个交易有一些 calldata

111
00:05:58,075 --> 00:06:00,660
你认为这次 receive 会被触发吗？

112
00:06:00,680 --> 00:06:03,510
如果我们点击 transact, Remix 会弹出一个窗口

113
00:06:03,510 --> 00:06:06,680
说 'Fallback' function is not defined

114
00:06:06,840 --> 00:06:10,666
这是因为每当数据与交易一起被发送时

115
00:06:10,666 --> 00:06:14,058
Solidity 会说,哦,好吧,既然你在发送数据

116
00:06:14,058 --> 00:06:17,290
那你不是在寻找 receive,你是在寻找某个函数

117
00:06:17,450 --> 00:06:19,270
所以让我为你寻找那个函数

118
00:06:19,320 --> 00:06:23,481
嗯,我没有看到任何符合 0x00 的函数

119
00:06:23,481 --> 00:06:26,200
所以我要去找你的 fallback 函数

120
00:06:26,200 --> 00:06:29,920
这里，Remix 很聪明,知道我们没有 fallback 函数

121
00:06:29,920 --> 00:06:33,640
Solidity 中的第二个特殊函数被称为 fallback 函数

122
00:06:33,640 --> 00:06:36,726
它与 receive 函数非常相似

123
00:06:36,726 --> 00:06:41,190
不同的是,即使数据与交易一起被发送,它也会被触发

124
00:06:41,190 --> 00:06:43,210
因此,我们的 fallback 函数将看起来像这样

125
00:06:43,330 --> 00:06:52,920
fallback() external payable{}, result = 2

126
00:06:52,920 --> 00:06:57,689
fallback 是另一个不需要加 function 关键字的函数

127
00:06:57,689 --> 00:06:59,320
因为 Solidity 知道这个规则

128
00:06:59,320 --> 00:07:02,980
实际上,你已经熟悉了另外一个特殊的函数

129
00:07:02,980 --> 00:07:04,788
我们回到我们的 FundMe 合约

130
00:07:04,788 --> 00:07:10,682
例如,构造函数,是另一种不需要 function 关键字的特殊函数

131
00:07:10,682 --> 00:07:15,630
Solidity 知道,当部署这个合约时,这个构造函数会被立即调用

132
00:07:15,630 --> 00:07:17,850
所以现在我们有了我们的 fallback 函数

133
00:07:17,850 --> 00:07:19,530
让我们继续并编译这个

134
00:07:19,610 --> 00:07:24,890
删除我们的旧合约, 然后部署这个新的合约

135
00:07:25,190 --> 00:07:27,810
就像这里,我们点击 result,

136
00:07:28,150 --> 00:07:30,290
我们确实做到了,看,它被设置为 0

137
00:07:30,450 --> 00:07:33,380
现在,如果我添加这个 0x00

138
00:07:33,380 --> 00:07:36,356
然后我发送这个,然后我点击 Transact

139
00:07:36,356 --> 00:07:40,530
这相当于调用一个合约中没有的函数

140
00:07:40,690 --> 00:07:43,820
所以我们的合约会说："我不知道你想告诉我什么,

141
00:07:43,820 --> 00:07:45,720
我要把你转到 fallback"

142
00:07:45,720 --> 00:07:49,780
现在,如果我们点击 result,我们看到它已经被更新为 2

143
00:07:49,940 --> 00:07:53,010
如果我们把这个拿开,Solidity 会说,嗯,

144
00:07:53,170 --> 00:07:55,036
看起来你想发送一些以太坊

145
00:07:55,036 --> 00:07:57,710
或者在没有指出要做什么的情况下，调用这个合约

146
00:07:57,880 --> 00:07:59,357
好吧,我有一个 receive 函数

147
00:07:59,357 --> 00:08:01,400
所以我接下来把你转到那个地方

148
00:08:01,560 --> 00:08:06,100
因此,如果我们调用 transact,我们点击 result,我们看到它更新为 1

149
00:08:06,100 --> 00:08:08,599
添加一些数据,点击 transact

150
00:08:08,599 --> 00:08:10,092
我们看到它更新为2

151
00:08:10,092 --> 00:08:12,480
不填数据，就会更新为 1

152
00:08:12,480 --> 00:08:15,908
solidity-by-example.org 有一个奇妙的小图例

153
00:08:15,908 --> 00:08:21,460
我们可以用来分析 receive 还是 fallback 会被触发

154
00:08:21,620 --> 00:08:25,880
如果它是空的, 并且有一个 receive 函数,它将调用 receive 函数

155
00:08:26,010 --> 00:08:31,250
如果有数据,并且没有 receive 函数,它就会去调用 fallback 函数

156
00:08:31,510 --> 00:08:34,840
如果没有 fallback 函数,它可能就会抛出 error

157
00:08:34,840 --> 00:08:37,440
因此,这里有很多非常棒的信息

158
00:08:37,440 --> 00:08:41,370
我们如何将其应用于我们的 FundMe 合约,

159
00:08:41,370 --> 00:08:44,025
或者我们现在可以在 FundMe 中做的就是

160
00:08:44,025 --> 00:08:46,907
就是添加这些 fallback 和 receive 函数

161
00:08:46,907 --> 00:08:52,150
以防有人向我们的合约发送资金，却没有正确使用 fund 函数

162
00:08:52,310 --> 00:08:55,231
所以我们可以做的是让我们添加一个 receive 函数

163
00:08:55,231 --> 00:08:57,407
因此,如果有人不小心把钱发给了合约

164
00:08:57,407 --> 00:08:59,090
我们仍然可以处理这个交易

165
00:08:59,090 --> 00:09:04,511
会使用 receive() external payable

166
00:09:04,511 --> 00:09:08,087
而我们只需让 receive 函数调用 fund 函数

167
00:09:08,087 --> 00:09:11,900
我们将在 fallback 函数中做同样的事情

168
00:09:11,900 --> 00:09:20,030
将使用 fallback() external payable,让它自动调用 fund 函数

169
00:09:20,230 --> 00:09:24,983
现在,如果有人不小心给我们转钱而不调用我们的 fund 函数

170
00:09:24,983 --> 00:09:29,150
它仍然会自动将他们转到 fund 函数

171
00:09:29,310 --> 00:09:30,544
这同时意味着

172
00:09:30,544 --> 00:09:33,040
如果有人没有给我们发送足够的资金

173
00:09:33,040 --> 00:09:35,910
该交易仍将被 revert

174
00:09:35,910 --> 00:09:38,401
我们现在切换到 Rinkeby

175
00:09:38,401 --> 00:09:40,272
在一个真实的测试网上测试它

176
00:09:40,272 --> 00:09:42,300
我在metamask上使用的是 Rinkeby

177
00:09:42,340 --> 00:09:46,760
让我们切换到 Injected Web3,然后向下滚动,

178
00:09:46,920 --> 00:09:51,822
我们将选择我们的 FundMe 合约,继续并部署

179
00:09:51,822 --> 00:09:55,470
 MetaMask 会弹出来，我将继续并确认交易

180
00:09:55,470 --> 00:09:57,960
我们现在看到我们的 FundMe 合约,我们可以看到所有者,

181
00:09:58,120 --> 00:10:00,280
我们可以看到我是所有者,

182
00:10:00,440 --> 00:10:02,690
我们可以看到 MINIMUM_USD

183
00:10:02,810 --> 00:10:06,450
当然,我们可以看到这是一个空白合约,这里没有任何资金

184
00:10:06,610 --> 00:10:10,969
如果我们复制这个地址, 然后进入 rinkeby Etherscan

185
00:10:10,969 --> 00:10:15,963
粘贴这个地址,我们可以看到这里没有以太币

186
00:10:15,963 --> 00:10:19,290
而与此相关的唯一交易是创建合约

187
00:10:19,470 --> 00:10:21,932
我们之前看到,当点击 fund 函数时

188
00:10:21,932 --> 00:10:25,595
合约被更新为新的余额

189
00:10:25,595 --> 00:10:27,820
并且那个出资人被添加到我们的数组中

190
00:10:27,820 --> 00:10:29,339
让我们看看现在会发生什么

191
00:10:29,339 --> 00:10:35,160
如果我们不调用 fund 函数而直接向这个合约发送资金

192
00:10:35,460 --> 00:10:39,440
如果我们做得对的话，receive 函数应该会获取到到这个交易

193
00:10:39,440 --> 00:10:42,760
并将交易转到 fund 函数上

194
00:10:42,760 --> 00:10:46,260
所以让我们复制这个地址，打开 MetaMask

195
00:10:46,260 --> 00:10:50,210
我们点击send，把这个地址粘贴到这里,

196
00:10:50,210 --> 00:10:52,752
同样是加上 0.02 的 ETH

197
00:10:52,752 --> 00:10:56,976
因为这应该超过了 usd 的最低数额限制

198
00:10:56,976 --> 00:10:58,750
点击下一步

199
00:10:58,750 --> 00:11:04,000
我将继续并确认这一点,稍微延迟后,如果我们这样做是对的

200
00:11:04,380 --> 00:11:08,560
我们应该看到交易调用了 fund 函数

201
00:11:08,560 --> 00:11:10,705
现在我们的交易已经通过了

202
00:11:10,705 --> 00:11:13,841
在等待 Etherscan 可以更新后

203
00:11:13,841 --> 00:11:19,860
我们确实看到余额已经更新为 0.02,当然, 这是讲得通的

204
00:11:20,020 --> 00:11:25,820
我们在交易列表中看到,我们看到这实际上是以转账的方式进行的

205
00:11:25,980 --> 00:11:27,820
而不是我们调用 fund 函数

206
00:11:27,980 --> 00:11:32,240
让我们在 Remix 中看看我们的 funders 是否被更新

207
00:11:32,240 --> 00:11:34,223
看起来它确实更新了

208
00:11:34,223 --> 00:11:37,625
在下标为 0 的位置上，是有地址的

209
00:11:37,625 --> 00:11:41,194
如果把地址放到 AddressToAmountFunded

210
00:11:41,194 --> 00:11:43,980
我们就可以看到我们到底有多少资金

211
00:11:44,160 --> 00:11:46,906
这意味着,由于在这里添加了 receive 函数

212
00:11:46,906 --> 00:11:50,540
我们就自动调用了这里的 fund 函数

213
00:11:50,540 --> 00:11:53,784
因此,了不起的工作,我们能够添加一个 receive 函数

214
00:11:53,784 --> 00:12:00,184
以帮助那些不小心调用了错误的函数或不小心给这个合约发送钱

215
00:12:00,184 --> 00:12:02,310
而不是正确地调用 fund 函数

216
00:12:02,430 --> 00:12:05,081
现在,如果他们直接调用 fund 函数

217
00:12:05,081 --> 00:12:07,193
这会帮助他少花一点 Gas

218
00:12:07,193 --> 00:12:09,369
至少这一次,他们会得到凭证

219
00:12:09,369 --> 00:12:10,915
合约会把它添加到我们的 funder 数组当中

220
00:12:10,915 --> 00:12:12,960
因为他们已经给我们的 FundMe 合约转过钱了

221
00:12:13,250 --> 00:12:13,310
Yeah.

